#!bin/pythion3
#
# MIT License
#
# Copyright (c) 2024 Dmitriy Nekrasov
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# ---------------------------------------------------------------------------------
#
# Script to generate initializing stuff for various designs (rom init files and
# verilog headers). Functions from here is also used by some tb/ programs to
# generate test data and coefficients.
#
# Currently supported:
#   * RAM FIR ( gen_ram_fir() function )
#   * looped/cascaded sos IIR ( gen_sos_iir() function )
#
# See more in the main README.md
#
# -- Dmitry Nekrasov <bluebag@yandex.ru>   Sun, 07 Apr 2024 18:29:33 +0300

import matplotlib.pyplot as plt
import numpy as np
from   scipy import signal

def draw_plot( b=None, sos=None ):
    if b is not None:
        w_fir, h_fir = signal.freqz(     b, worN=8000)
        plt.plot( w_fir * 44100 /(np.pi*2), np.abs(h_fir), color='blue', label='FIR')
    if sos is not None:
        w_iir, h_iir = signal.sosfreqz(sos, worN=8000)
        plt.plot( w_iir * 44100 /(np.pi*2), np.abs(h_iir), color='red',  label='IIR')
    plt.ylabel('Gain', color='b')
    plt.xlabel('Frequency')
    plt.axhline(0.5, alpha=0.3, color='k', linestyle='--', linewidth=1)
    plt.grid(True)
    plt.yscale('log')
    plt.ylim([10e-10, 10])
    plt.xlim(left=0)
    #plt.xlim(right=1000)
    plt.legend()
    plt.show()


def float_to_twos_complement( x, cw ):
    x_ = np.ravel(x) if len(x.shape) > 1 else x
    y = np.zeros(len(x_), dtype=int )
    for i in range( len(x_) ):
        y[i] = int(round( 2**(cw-1) * x_[i] ) )
        if( y[i] < 0 ):
            try:
                y[i] = ( (2**cw-1) ^ y[i] ) + 1
            except TypeError:
                pass
            y[i] = abs(y[i])
    return np.reshape( y, x.shape )


def gen_ram_fir( ntaps, cutoff, cw, filter_type, rom_fname=None ):
    N = int(2**(np.ceil(np.log2(ntaps))))
    pass_zero = True if filter_type=="lowpass" else False
    b = signal.firwin( numtaps=ntaps, cutoff=cutoff, fs=44100, pass_zero=pass_zero )
    if rom_fname is not None:
        fmt = lambda x : ("0"*int(np.ceil(cw/4) - len("%x"%x)) ) + "%x"%x
        b_2sc = float_to_twos_complement( b, cw )
        f = open( rom_fname, "w" )
        f.write( '// This file is automatically generated by filter_generator.py program\n');
        f.write(f'// Number of taps : {ntaps}\n');
        f.write(f'// Cutoff frequency : {cutoff} Hz\n');
        f.write(f'// Type : {filter_type}\n');
        f.write(f'// WIDTH={cw};\n');
        f.write(f'// DEPTH={N};\n');
        f.write( '// DATA_RADIX=HEX;\n\n');
        for i in range( len( b_2sc ) ):
          f.write( f"{fmt(b_2sc[i])}\n" )
        f.close()
    # return floored value
    return np.fix( b * 2**(cw-1) ) / 2**(cw-1)


# Returns a1 and a2 for DIRECT FORM, not for TRANSPOSED form!!
def gen_sos_iir( ntaps, cutoff, cw, filter_type, verilog_header_fname=None ):
    ##########################################################################################
    ################################## NESTED FUNCTIONS ######################################
    #
    # Our RTL design is based on some expectations on the coefficents. This
    # funcion makes sure does they meet these expectations or doesn't
    def butterworth_check( sos ):
        z,p,k = signal.sos2zpk( sos )
        # If it became unstable
        if( max(abs(p)) >= 1 ):
            print_and_exit( f"The filter became unstable after quantizing coefficients to {cw} bits! Aborting" )
        # If 0th section feedforward coefficients became 0 after rounding
        if( any(sos[0][:3]) == 0 ):
            print_and_exit( f"Can't make filter of this order having only {cw} bits for coefficients")
        # If feedforward coefficients for other sections is something other than 1,  +-2,  1
        for i in range(1, len(sos)):
            if( any( ( sos[i][0], sos[i][2] ) ) != 1.0 ):
                print_and_exit( "Error, b0/b2 coefficints other than 1.0 only allowed in the 0th section" )
            if( sos[i][1] not in {2.0, -2.0}):
                print_and_exit( "Error, b1 coefficints other than +-2.0 only allowed in the 0th section" )
        # Check range
        if( any( ( sos[0][:3] <= -1 ) | ( sos[0][:3] >= 1 ) ) ):
            print_and_exit( "Error, 0th section b0/b1/b2 coefficints must be inside 0-1 range" )
        if( any( ( sos[:,4] <= -2 ) | ( sos[:,4] >= 2 ) ) ):
            print_and_exit( "Error, a1 coefficints must be inside 0-2 range" )
        if( any( ( sos[:,5] <= -1 ) | ( sos[:,5] >= 1 ) ) ):
            print_and_exit( "Error, a2 coefficints must be inside 0-1 range" )
        # Highly unlikely, just formal to make checking complete
        if( any(sos[:,3]) != 1.0 ):
            print_and_exit("Wtf man, how a1 coefficint could be something other than 1..")
    #
    # second order sections formatted print
    def print_sos( sos, dtype=float ):
        print("")
        for i in range(len(sos)):
            for j in range(6):
                if( dtype==float ):
                    print( "%s " % (((" "*20 + "%6e"%sos[i][j])[::-1])[:18])[::-1], end='' )
                elif( dtype==int ):
                    print( "%s " % (((" "*20 +  "%x"%sos[i][j])[::-1])[:18])[::-1], end='' )
                else:
                    print("print sos: wrong type")
            print("")
        print("")
    #
    #
    def print_and_exit( string ):
        print( string )
        print( sos )
        print( sos_floored )
        exit()
    #
    ##########################################################################################
    ################################### FUNCTION ROUTINE #####################################
    #
    sos = signal.iirfilter( N=ntaps, Wn=cutoff, btype=filter_type, fs=44100, output='sos' )
    print_sos(sos)
    sos_floored = np.fix( sos * 2**(cw-1) ) / 2**(cw-1)
    butterworth_check( sos_floored )
    #print_sos(sos)
    #
    # This is because scipy.iirfilter returns sos coefficents for TRANSPOSED
    # form. I want to be more general about this and return "neutral" stuff.
    # Anyway, I write it everywhere that this frunction returns and generates
    # coefficints for DIRECT form, NOT TRANSPOSED
    sos_floored[:,4] = -sos_floored[:,4]
    sos_floored[:,5] = -sos_floored[:,5]
    #
    # If we get here, everything is alright, we can generate veriog header (if it is required)
    if verilog_header_fname is not None:
        fmt = lambda x : ("0"*int(np.ceil( cw / 4) - len("%x"%x)) ) + "%x"%x
        from copy import copy
        sos_tmp = copy(sos_floored)
        sos_tmp[:,4] = sos_tmp[:,4] / 2
        sos_2sc = float_to_twos_complement( sos_tmp, cw )
        print_sos( sos_2sc, dtype=int )
        f = open( verilog_header_fname, "w" )
        f.write( "{ " )
        for i in range(len(sos_2sc)-1,-1,-1):
            f.write( f"{cw}'sh_{fmt(sos_2sc[i][5])}, ")
        for i in range(len(sos_2sc)-1,-1,-1):
            f.write( f"{cw}'sh_{fmt(sos_2sc[i][4])}, ")
        f.write( f"{cw}'sh_{fmt(sos_2sc[0][2])}, ")
        f.write( f"{cw}'sh_{fmt(sos_2sc[0][1])}, ")
        f.write( f"{cw}'sh_{fmt(sos_2sc[0][0])}  ")
        f.write("}\n")
        f.close()
    return sos_floored


if __name__ == '__main__':
    ###########################################################
    # Control point:
    GENERATE_FIR             = False
    GENERATE_IIR             = True
    NTAPS                    = 8
    FSAMPLE                  = 44100
    CUTOFF                   = FSAMPLE//4 + 4000
    COEFFICIENT_WIDTH        = 8
    FILTER_TYPE              = ( "lowpass", "highpass" )[0]
    RAM_FIR_ROM_FNAME        = None # 'your_meory_initializing_file_here.mem'
    IIR_VERILOG_HEADER_FNAME = None # 'test.sv'
    DRAW_PLOT_EN             = True
    ###########################################################
    sos, b = None, None
    if( GENERATE_FIR ):
        b   = gen_ram_fir( ntaps            = NTAPS,
                           cutoff           = CUTOFF,
                           cw               = COEFFICIENT_WIDTH,
                           filter_type      = FILTER_TYPE,
                           rom_fname        = RAM_FIR_ROM_FNAME
                           )
    if( GENERATE_IIR ):
        sos = gen_sos_iir( ntaps                = NTAPS,
                           cutoff               = CUTOFF,
                           cw                   = COEFFICIENT_WIDTH,
                           filter_type          = FILTER_TYPE,
                           verilog_header_fname = IIR_VERILOG_HEADER_FNAME
                           )

    if( DRAW_PLOT_EN ):
        draw_plot( b, sos )


